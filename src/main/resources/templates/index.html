<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Sudoku Game</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        body {
            padding-bottom: 70px;
            background-color: #f8f9fa;
        }

        .sudoku-grid {
            border-collapse: collapse;
            margin: 20px auto;
            border: 3px solid #000;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .sudoku-grid td {
            border: 1px solid #666;
            padding: 0;
            position: relative;
        }

        .sudoku-grid td:nth-child(3n) {
            border-right: 3px solid #000;
        }

        .sudoku-grid tr:nth-child(3n) td {
            border-bottom: 3px solid #000;
        }

        .sudoku-grid input {
            width: 50px;
            height: 50px;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            border: none;
            background: transparent;
            outline: none;
            transition: all 0.3s ease;
        }

        .sudoku-grid input.subgrid {
            background-color: #f0f8ff;
        }

        .sudoku-grid input.invalid {
            background-color: #ffebee;
            color: #d32f2f;
            animation: shake 0.5s ease-in-out;
            border: 2px solid #d32f2f;
        }

        .sudoku-grid input.prefilled {
            background-color: #e8f5e8;
            color: #2e7d32;
            font-weight: bold;
        }

        .sudoku-grid input:focus {
            background-color: #fff3e0;
            box-shadow: inset 0 0 5px rgba(255, 152, 0, 0.5);
        }

        .sudoku-grid input.highlighted {
            background-color: #e3f2fd;
            box-shadow: 0 0 5px rgba(33, 150, 243, 0.5);
        }

        .sudoku-grid input.duplicate {
            background-color: #fff3e0;
            color: #f57c00;
            font-weight: bold;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .control-panel {
            margin: 20px 0;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px 20px;
            background-color: #343a40;
            color: white;
            border-top: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        .btn-group-custom {
            margin: 10px 0;
        }

        .btn-group-custom .btn {
            margin-right: 5px;
            margin-bottom: 5px;
        }

        .section-divider {
            margin: 20px 0;
            border-bottom: 1px solid #dee2e6;
        }

        .timer-display {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #28a745;
        }

        .status-message {
            font-weight: 500;
        }

        .mistakes-counter {
            color: #dc3545;
            font-weight: bold;
        }

        .game-over-modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: none;
            border-radius: 10px;
            width: 300px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .instructions {
            background-color: #e7f3ff;
            border: 1px solid #b3d9ff;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
        }

        .instructions h6 {
            color: #0056b3;
            margin-bottom: 10px;
        }

        .instructions ul {
            margin: 0;
            padding-left: 20px;
        }

        .instructions li {
            margin: 5px 0;
            font-size: 14px;
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #6c757d;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #495057;
        }

        .error-message {
            color: #dc3545;
            font-size: 14px;
            margin-top: 5px;
            display: none;
        }

        .validation-hints {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 5px;
            padding: 10px;
            margin: 10px 0;
        }

        .validation-hints h6 {
            color: #856404;
            margin-bottom: 8px;
        }

        .hint-item {
            font-size: 12px;
            color: #856404;
            margin: 3px 0;
        }
    </style>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h1 class="text-center mt-3 mb-4">Advanced Sudoku Game</h1>
        </div>
    </div>

    <div class="row">
        <div class="col-lg-8 col-md-7">
            <div class="d-flex justify-content-center">
                <table class="sudoku-grid">
                    <tbody id="sudoku-tbody">
                    <!-- Grid will be generated by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div class="error-message text-center" id="error-message"></div>
        </div>

        <div class="col-lg-4 col-md-5">
            <div class="control-panel">
                <h3 class="text-center mb-4">Sudoku Controls</h3>

                <!-- Game Stats -->
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-label">Mistakes</div>
                        <div class="stat-value mistakes-counter" id="mistakes-display">0/3</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Timer</div>
                        <div class="stat-value timer-display" id="timer-display">00:00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Difficulty</div>
                        <div class="stat-value" id="current-difficulty">Medium</div>
                    </div>
                </div>

                <!-- Validation Hints -->
                <div class="validation-hints">
                    <h6>Live Validation:</h6>
                    <div class="hint-item">✓ Real-time error detection</div>
                    <div class="hint-item">✓ Duplicate number highlighting</div>
                    <div class="hint-item">✓ Invalid moves prevention</div>
                    <div class="hint-item">✓ Visual feedback for errors</div>
                </div>

                <!-- Instructions -->
                <div class="instructions">
                    <h6>How to play Sudoku:</h6>
                    <ul>
                        <li>Fill each row with numbers 1-9 (no duplicates)</li>
                        <li>Fill each column with numbers 1-9 (no duplicates)</li>
                        <li>Fill each 3×3 grid with numbers 1-9 (no duplicates)</li>
                        <li>You have 3 mistakes allowed per game</li>
                        <li>Invalid entries will be highlighted in red</li>
                        <li>Use arrow keys to navigate between cells</li>
                    </ul>
                </div>

                <!-- Solving Actions -->
                <div class="solving-actions">
                    <h5>Solve Puzzle</h5>
                    <div class="btn-group-custom">
                        <button class="btn btn-success" onclick="solve('backtracking')">
                            🚀 Solve Puzzle
                        </button>
                        <button class="btn btn-info" onclick="getHint()">
                            💡 Get Hint
                        </button>
                    </div>
                </div>

                <div class="section-divider"></div>

                <!-- Puzzle Generation -->
                <div class="puzzle-actions">
                    <h5>Generate New Puzzle</h5>
                    <div class="difficulty-selector">
                        <label for="difficulty">Difficulty Level:</label>
                        <select id="difficulty" class="form-control">
                            <option value="easy">Easy (40 clues)</option>
                            <option value="medium" selected>Medium (30 clues)</option>
                            <option value="hard">Hard (25 clues)</option>
                        </select>
                    </div>
                    <button class="btn btn-primary btn-block" onclick="generatePuzzle()">
                        🎲 Generate Puzzle
                    </button>
                </div>

                <div class="section-divider"></div>

                <!-- Puzzle Management -->
                <div class="puzzle-actions">
                    <h5>Puzzle Management</h5>
                    <div class="btn-group-custom">
                        <button class="btn btn-outline-primary" onclick="savePuzzle()">
                            💾 Save Puzzle
                        </button>
                        <button class="btn btn-outline-secondary" onclick="loadPuzzle()">
                            📁 Load Puzzle
                        </button>
                    </div>
                </div>

                <div class="section-divider"></div>

                <!-- Utility Actions -->
                <div class="utility-actions">
                    <h5>Utilities</h5>
                    <div class="btn-group-custom">
                        <button class="btn btn-outline-success" onclick="validateBoard()">
                            ✅ Validate
                        </button>
                        <button class="btn btn-outline-danger" onclick="clearBoard()">
                            🗑️ Clear Board
                        </button>
                        <button class="btn btn-outline-info" onclick="resetTimer()">
                            ⏰ Reset Timer
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Fixed Status Bar -->
<div class="status-bar">
    <span id="status" class="status-message">Generate a new puzzle to start playing!</span>
    <span id="timer" class="timer-display">Time: 00:00</span>
</div>

<!-- Game Over Modal -->
<div id="gameOverModal" class="game-over-modal">
    <div class="modal-content">
        <h4>Game Over</h4>
        <p id="gameOverMessage">You have made 3 mistakes and lost this game</p>
        <button class="btn btn-primary" onclick="secondChance()">Second Chance</button>
        <button class="btn btn-secondary" onclick="newGame()">New Game</button>
    </div>
</div>

<!-- Loading Scripts -->
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script>
    let board = Array(9).fill().map(() => Array(9).fill('.'));
    let originalBoard = Array(9).fill().map(() => Array(9).fill('.'));
    let solution = Array(9).fill().map(() => Array(9).fill('.'));
    let isSolving = false;
    let timerInterval;
    let gameStarted = false;
    let mistakes = 0;
    let maxMistakes = 3;
    let gameOver = false;
    let savedPuzzles = [];
    let currentFocusedCell = null;

    // Initialize game
    $(document).ready(function() {
    generateGrid();
    updateGrid();
    $('#status').text('Generate a new puzzle to start playing!');
    loadSavedPuzzles();
    // Remove this line: loadExamplePuzzle();
});

    function generateGrid() {
        let gridHTML = '';
        for (let i = 0; i < 9; i++) {
            gridHTML += '<tr>';
            for (let j = 0; j < 9; j++) {
                const isSubgrid = (Math.floor(i / 3) + Math.floor(j / 3)) % 2 === 0;
                const subgridClass = isSubgrid ? 'subgrid' : '';
                gridHTML += `<td>
                    <input type="text"
                           maxlength="1"
                           pattern="[1-9]?"
                           class="${subgridClass}"
                           id="cell-${i}-${j}"
                           oninput="updateBoard(this, ${i}, ${j})"
                           onkeydown="handleKeyDown(event, ${i}, ${j})"
                           onfocus="handleCellFocus(${i}, ${j})"
                           onblur="handleCellBlur(${i}, ${j})"
                           autocomplete="off">
                </td>`;
            }
            gridHTML += '</tr>';
        }
        $('#sudoku-tbody').html(gridHTML);
    }

    function handleKeyDown(event, row, col) {
        if (gameOver) return;

        // Allow backspace and delete
        if (event.key === 'Backspace' || event.key === 'Delete') {
            if (originalBoard[row][col] === '.') {
                board[row][col] = '.';
                $(`#cell-${row}-${col}`).val('');
                clearValidationHighlights();
                validateBoardRealTime();
            }
            return;
        }

        // Only allow numbers 1-9
        if (event.key >= '1' && event.key <= '9') {
            return true;
        }

        // Arrow key navigation
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
            navigateGrid(event.key, row, col);
            event.preventDefault();
            return false;
        }

        // Block all other keys
        event.preventDefault();
        return false;
    }

    function navigateGrid(key, row, col) {
        let newRow = row;
        let newCol = col;

        switch(key) {
            case 'ArrowUp':
                newRow = row > 0 ? row - 1 : 8;
                break;
            case 'ArrowDown':
                newRow = row < 8 ? row + 1 : 0;
                break;
            case 'ArrowLeft':
                newCol = col > 0 ? col - 1 : 8;
                break;
            case 'ArrowRight':
                newCol = col < 8 ? col + 1 : 0;
                break;
        }

        $(`#cell-${newRow}-${newCol}`).focus();
    }

    function handleCellFocus(row, col) {
        currentFocusedCell = {row, col};
        highlightRelatedCells(row, col);
    }

    function handleCellBlur(row, col) {
        currentFocusedCell = null;
        clearHighlights();
    }

    function highlightRelatedCells(row, col) {
        clearHighlights();

        // Highlight same row, column, and 3x3 box
        for (let i = 0; i < 9; i++) {
            // Same row
            if (i !== col) {
                $(`#cell-${row}-${i}`).addClass('highlighted');
            }
            // Same column
            if (i !== row) {
                $(`#cell-${i}-${col}`).addClass('highlighted');
            }
        }

        // Same 3x3 box
        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (i !== row || j !== col) {
                    $(`#cell-${i}-${j}`).addClass('highlighted');
                }
            }
        }
    }

    function clearHighlights() {
        $('.sudoku-grid input').removeClass('highlighted');
    }

    function updateBoard(element, i, j) {
        if (gameOver) return;

        const value = element.value;
        const oldValue = board[i][j];

        // Only allow digits 1-9 or empty
        if (value !== '' && !value.match(/^[1-9]$/)) {
            element.value = board[i][j] === '.' ? '' : board[i][j];
            return;
        }

        // Don't allow modification of prefilled cells
        if (originalBoard[i][j] !== '.') {
            element.value = originalBoard[i][j];
            return;
        }

        // Start timer on first move
        if (!gameStarted && value !== '') {
            startTimer();
            gameStarted = true;
        }

        board[i][j] = value === '' ? '.' : value;

        // Clear previous validation highlights
        clearValidationHighlights();

        // Real-time validation
        validateBoardRealTime();

        // Check for validity and handle mistakes
        if (value !== '' && !isValidMove(i, j, value)) {
            element.classList.add('invalid');
            showError(`Invalid move: ${value} conflicts with existing numbers`);

            if (oldValue !== value) {
                mistakes++;
                updateMistakesDisplay();

                if (mistakes >= maxMistakes) {
                    setTimeout(() => endGame(), 500);
                }
            }
        } else {
            element.classList.remove('invalid');
            hideError();

            if (isPuzzleComplete()) {
                setTimeout(() => completePuzzle(), 500);
            }
        }
    }

    function validateBoardRealTime() {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const value = board[i][j];
                if (value !== '.') {
                    const cell = $(`#cell-${i}-${j}`);

                    if (hasDuplicates(i, j, value)) {
                        cell.addClass('duplicate');
                    } else {
                        cell.removeClass('duplicate');
                    }
                }
            }
        }
    }

    function hasDuplicates(row, col, value) {
        for (let j = 0; j < 9; j++) {
            if (j !== col && board[row][j] === value) {
                return true;
            }
        }

        for (let i = 0; i < 9; i++) {
            if (i !== row && board[i][col] === value) {
                return true;
            }
        }

        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if ((i !== row || j !== col) && board[i][j] === value) {
                    return true;
                }
            }
        }

        return false;
    }

    function clearValidationHighlights() {
        $('.sudoku-grid input').removeClass('duplicate invalid');
    }

    function showError(message) {
        $('#error-message').text(message).show();
        setTimeout(() => hideError(), 3000);
    }

    function hideError() {
        $('#error-message').hide();
    }

    function isValidMove(row, col, num) {
        const tempBoard = board.map(row => [...row]);

        for (let i = 0; i < 9; i++) {
            if (i !== col && tempBoard[row][i] === num) {
                return false;
            }
        }

        for (let i = 0; i < 9; i++) {
            if (i !== row && tempBoard[i][col] === num) {
                return false;
            }
        }

        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if ((i !== row || j !== col) && tempBoard[i][j] === num) {
                    return false;
                }
            }
        }

        return true;
    }

    function solve(method) {
        if (isSolving || gameOver) return;

        isSolving = true;
        $('#status').text('Solving...');

        setTimeout(() => {
            const boardCopy = board.map(row => [...row]);
            if (solveSudoku(boardCopy)) {
                board = boardCopy;
                solution = boardCopy.map(row => [...row]);
                updateGrid();
                $('#status').text('Puzzle solved!');
                stopTimer();
                gameOver = true;
            } else {
                $('#status').text('No solution found!');
            }
            isSolving = false;
        }, 500);
    }

    function getHint() {
        if (gameOver) return;

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] === '.' && originalBoard[i][j] === '.') {
                    const solutionCopy = board.map(row => [...row]);
                    if (solveSudoku(solutionCopy)) {
                        const hintValue = solutionCopy[i][j];
                        board[i][j] = hintValue;
                        updateGrid();
                        $(`#cell-${i}-${j}`).addClass('hint-cell').css('background-color', '#e8f5e8');
                        $('#status').text(`Hint: Added ${hintValue} at row ${i+1}, column ${j+1}`);

                        if (isPuzzleComplete()) {
                            setTimeout(() => completePuzzle(), 500);
                        }
                        return;
                    }
                }
            }
        }

        $('#status').text('No hints available - puzzle might be complete!');
    }

    function solveSudoku(board) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = 1; num <= 9; num++) {
                        if (isValidPlacement(board, row, col, num.toString())) {
                            board[row][col] = num.toString();
                            if (solveSudoku(board)) {
                                return true;
                            }
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    function isValidPlacement(board, row, col, num) {
        for (let i = 0; i < 9; i++) {
            if (board[row][i] === num) return false;
        }

        for (let i = 0; i < 9; i++) {
            if (board[i][col] === num) return false;
        }

        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (board[i][j] === num) return false;
            }
        }

        return true;
    }

    function loadExamplePuzzle() {
    if (confirm('Load example puzzle? This will replace current game.')) {
        const examplePuzzle = [
            ['4', '.', '7', '.', '.', '.', '.', '.', '.'],
            ['.', '5', '.', '7', '.', '.', '.', '4', '.'],
            ['.', '1', '9', '.', '.', '4', '7', '.', '8'],
            ['8', '2', '.', '6', '7', '5', '9', '4', '1'],
            ['1', '6', '5', '4', '9', '8', '.', '.', '7'],
            ['7', '4', '.', '2', '1', '3', '5', '.', '6'],
            ['5', '7', '8', '9', '4', '2', '.', '.', '.'],
            ['2', '3', '1', '8', '5', '6', '4', '7', '9'],
            ['6', '9', '4', '1', '3', '7', '.', '.', '2']
        ];

        board = examplePuzzle.map(row => [...row]);
        originalBoard = examplePuzzle.map(row => [...row]);

        resetGame();
        updateGrid();
        $('#status').text('Example puzzle loaded! Start playing.');
        $('#current-difficulty').text('Example');
    }
}

    function generatePuzzle() {
        if (gameOver) return;

        $('#status').text('Generating puzzle...');

        const difficulty = $('#difficulty').val();
        $('#current-difficulty').text(difficulty.charAt(0).toUpperCase() + difficulty.slice(1));

        setTimeout(() => {
            const newBoard = Array(9).fill().map(() => Array(9).fill('.'));

            for (let i = 0; i < 9; i += 3) {
                fillBox(newBoard, i, i);
            }

            if (!solveSudoku(newBoard)) {
                $('#status').text('Failed to generate a valid puzzle!');
                return;
            }

            solution = newBoard.map(row => [...row]);
            let clues;
            switch (difficulty) {
                case 'easy': clues = 40; break;
                case 'medium': clues = 30; break;
                case 'hard': clues = 25; break;
                default: clues = 30;
            }

            const positions = [];
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    positions.push([i, j]);
                }
            }
            shuffleArray(positions);

            let removed = 0;
            const tempBoard = newBoard.map(row => [...row]);
            for (const [row, col] of positions) {
                if (removed >= 81 - clues) break;
                const backup = tempBoard[row][col];
                tempBoard[row][col] = '.';
                const tempSolution = tempBoard.map(row => [...row]);
                if (solveSudoku(tempSolution)) {
                    newBoard[row][col] = '.';
                    removed++;
                } else {
                    tempBoard[row][col] = backup;
                }
            }

            board = newBoard;
            originalBoard = newBoard.map(row => [...row]);

            resetGame();
            updateGrid();
            $('#status').text(`New ${difficulty} puzzle generated! Start playing.`);
        }, 500);
    }

    function fillBox(board, startRow, startCol) {
        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        shuffleArray(numbers);

        let index = 0;
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                board[i][j] = numbers[index++].toString();
            }
        }
    }

    function removeNumbers(board, clues) {
        const numbersToRemove = 81 - clues;
        const positions = [];

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                positions.push([i, j]);
            }
        }

        shuffleArray(positions);

        let removed = 0;
        for (const [row, col] of positions) {
            if (removed >= numbersToRemove) break;

            board[row][col] = '.';
            removed++;
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function savePuzzle() {
        if (board.every(row => row.every(cell => cell === '.'))) {
            $('#status').text('No puzzle to save!');
            return;
        }

        const puzzle = {
            id: Date.now(),
            board: board.map(row => row.join('')).join('\n'),
            original: originalBoard.map(row => row.join('')).join('\n'),
            difficulty: $('#difficulty').val(),
            createdAt: new Date().toISOString()
        };

        savedPuzzles.push(puzzle);
        try {
            localStorage.setItem('sudokuPuzzles', JSON.stringify(savedPuzzles));
            $('#status').text(`Puzzle saved successfully! ID: ${puzzle.id}`);
        } catch (error) {
            $('#status').text('Error saving puzzle!');
        }
    }

    function loadPuzzle() {
        if (savedPuzzles.length === 0) {
            $('#status').text('No saved puzzles found!');
            return;
        }

        const puzzleId = prompt('Enter puzzle ID to load:');
        if (!puzzleId) return;

        const puzzle = savedPuzzles.find(p => p.id.toString() === puzzleId);
        if (!puzzle) {
            $('#status').text('Puzzle not found!');
            return;
        }

        const boardData = puzzle.board.split('\n').map(row => row.split(''));
        const originalData = puzzle.original.split('\n').map(row => row.split(''));

        board = boardData;
        originalBoard = originalData;

        resetGame();
        updateGrid();
        $('#status').text(`Puzzle ${puzzleId} loaded successfully!`);
        $('#current-difficulty').text(puzzle.difficulty.charAt(0).toUpperCase() + puzzle.difficulty.slice(1));
    }

    function loadSavedPuzzles() {
        try {
            const saved = localStorage.getItem('sudokuPuzzles');
            if (saved) {
                savedPuzzles = JSON.parse(saved);
            }
        } catch (error) {
            console.error('Error loading saved puzzles:', error);
        }
    }

    function validateBoard() {
        if (gameOver) return;

        let isValid = true;
        let errorCount = 0;

        $('.sudoku-grid input').removeClass('invalid duplicate');

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const value = board[i][j];
                if (value !== '.') {
                    if (!isValidMove(i, j, value)) {
                        isValid = false;
                        errorCount++;
                        $(`#cell-${i}-${j}`).addClass('invalid');
                    }
                }
            }
        }

        if (isValid) {
            $('#status').text('Board validation passed! ✅');
        } else {
            $('#status').text(`Board validation failed! ${errorCount} errors found. ❌`);
        }
    }

    function clearBoard() {
        if (confirm('Are you sure you want to clear the board?')) {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (originalBoard[i][j] === '.') {
                        board[i][j] = '.';
                    }
                }
            }
            updateGrid();
            clearValidationHighlights();
            $('#status').text('Board cleared!');
        }
    }

    function resetTimer() {
        stopTimer();
        timerInterval = null;
        gameStarted = false;
        $('#timer-display').text('00:00');
        $('#timer').text('Time: 00:00');
        $('#status').text('Timer reset!');
    }

    function resetGame() {
        mistakes = 0;
        gameOver = false;
        gameStarted = false;
        stopTimer();
        updateMistakesDisplay();
        clearValidationHighlights();
        $('.sudoku-grid input').removeClass('invalid duplicate hint-cell');
        $('#gameOverModal').hide();
    }

    function updateGrid() {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const cell = $(`#cell-${i}-${j}`);
                const value = board[i][j];

                cell.val(value === '.' ? '' : value);

                if (originalBoard[i][j] !== '.') {
                    cell.addClass('prefilled');
                    cell.prop('readonly', true);
                } else {
                    cell.removeClass('prefilled');
                    cell.prop('readonly', false);
                }
            }
        }
    }

    function startTimer() {
        if (timerInterval) return;

        let seconds = 0;
        timerInterval = setInterval(() => {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;

            $('#timer-display').text(timeString);
            $('#timer').text(`Time: ${timeString}`);
        }, 1000);
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    function updateMistakesDisplay() {
        $('#mistakes-display').text(`${mistakes}/${maxMistakes}`);
    }

    function isPuzzleComplete() {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] === '.') {
                    return false;
                }
            }
        }

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (!isValidMove(i, j, board[i][j])) {
                    return false;
                }
            }
        }

        return true;
    }

    function completePuzzle() {
        stopTimer();
        gameOver = true;
        const timeString = $('#timer-display').text();
        $('#status').text(`🎉 Congratulations! Puzzle completed in ${timeString} with ${mistakes} mistakes!`);

        $('.sudoku-grid').addClass('pulse');
        setTimeout(() => {
            $('.sudoku-grid').removeClass('pulse');
        }, 1000);
    }

    function endGame() {
        stopTimer();
        gameOver = true;
        $('#gameOverMessage').text(`You have made ${maxMistakes} mistakes and lost this game.`);
        $('#gameOverModal').show();
        $('#status').text('Game Over - Too many mistakes!');
    }

    function secondChance() {
        mistakes = 0;
        gameOver = false;
        updateMistakesDisplay();
        $('#gameOverModal').hide();
        $('#status').text('Second chance granted! Be careful with your moves.');

        $('.sudoku-grid input').removeClass('invalid');

        if (gameStarted) {
            startTimer();
        }
    }

    function newGame() {
        $('#gameOverModal').hide();
        generatePuzzle();
    }

    $('<style>').text(`
        .pulse {
            animation: pulse 1s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    `).appendTo('head');

    $(document).keydown(function(e) {
        if (gameOver) return;

        if (e.ctrlKey && e.key === 'n') {
            e.preventDefault();
            generatePuzzle();
        }

        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            savePuzzle();
        }

        if (e.ctrlKey && e.key === 'l') {
            e.preventDefault();
            loadPuzzle();
        }

        if (e.ctrlKey && e.key === 'h') {
            e.preventDefault();
            getHint();
        }

        if (e.ctrlKey && e.key === 'v') {
            e.preventDefault();
            validateBoard();
        }

        if (e.key === 'Escape') {
            $('#gameOverModal').hide();
        }
    });

    $(document).click(function(e) {
        if ($(e.target).is('#gameOverModal')) {
            $('#gameOverModal').hide();
        }
    });

    setInterval(function() {
        if (gameStarted && !gameOver && !board.every(row => row.every(cell => cell === '.'))) {
            const autoSave = {
                id: 'autosave',
                board: board.map(row => row.join('')).join('\n'),
                original: originalBoard.map(row => row.join('')).join('\n'),
                difficulty: $('#difficulty').val(),
                createdAt: new Date().toISOString(),
                mistakes: mistakes,
                time: $('#timer-display').text()
            };

            try {
                localStorage.setItem('sudokuAutoSave', JSON.stringify(autoSave));
            } catch (error) {
                console.error('Auto-save failed:', error);
            }
        }
    }, 30000);

    function loadAutoSave() {
        try {
            const autoSave = localStorage.getItem('sudokuAutoSave');
            if (autoSave) {
                const data = JSON.parse(autoSave);
                if (confirm('Auto-saved game found. Would you like to continue?')) {
                    const boardData = data.board.split('\n').map(row => row.split(''));
                    const originalData = data.original.split('\n').map(row => row.split(''));

                    board = boardData;
                    originalBoard = originalData;
                    mistakes = data.mistakes || 0;

                    resetGame();
                    updateGrid();
                    updateMistakesDisplay();
                    $('#status').text('Auto-saved game loaded!');
                    $('#current-difficulty').text(data.difficulty.charAt(0).toUpperCase() + data.difficulty.slice(1));
                }
            }
        } catch (error) {
            console.error('Error loading auto-save:', error);
        }
    }

    setTimeout(loadAutoSave, 1000);
</script>
</body>
</html>