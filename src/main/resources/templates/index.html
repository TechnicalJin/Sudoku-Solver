<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Sudoku Game</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        :root {
            --primary: #4361ee;
            --primary-light: #4895ef;
            --secondary: #3f37c9;
            --accent: #f72585;
            --success: #4cc9f0;
            --warning: #ffd166;
            --danger: #ef476f;
            --dark: #1e1e2e;
            --light: #f8f9fa;
            --grid-bg: #2d3047;
            --grid-cell: #3a3e5c;
            --grid-border: #4a4f7a;
            --subgrid-1: rgba(67, 97, 238, 0.15);
            --subgrid-2: rgba(79, 173, 230, 0.15);
            --subgrid-3: rgba(76, 201, 240, 0.15);
            --neon-glow: 0 0 10px rgba(67, 97, 238, 0.7),
                         0 0 20px rgba(67, 97, 238, 0.5),
                         0 0 30px rgba(67, 97, 238, 0.3);
        }

        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Orbitron:wght@400;500;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            padding-bottom: 100px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 10% 20%, rgba(67, 97, 238, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(243, 114, 182, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 50% 50%, rgba(76, 201, 240, 0.05) 0%, transparent 30%);
            z-index: -1;
        }

        .container-fluid {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            text-shadow: 0 0 10px rgba(76, 201, 240, 0.5);
        }

        .header-section {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .header-section::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(67, 97, 238, 0.1), transparent);
            animation: header-glow 6s infinite linear;
        }

        @keyframes header-glow {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, var(--primary-light), var(--success));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            max-width: 600px;
            margin: 0 auto 20px;
        }

        .sudoku-grid-container {
            perspective: 1000px;
            padding: 20px;
            background: rgba(30, 30, 46, 0.6);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3),
                        inset 0 0 20px rgba(67, 97, 238, 0.2);
            border: 1px solid var(--grid-border);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            transition: transform 0.5s ease;
        }

        .sudoku-grid-container::before {
            content: "";
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg,
                var(--primary), var(--secondary), var(--accent), var(--success));
            z-index: -1;
            border-radius: 22px;
            animation: border-glow 3s infinite alternate;
        }

        @keyframes border-glow {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .sudoku-grid {
            border-collapse: collapse;
            margin: 0 auto;
            background-color: var(--grid-bg);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4);
            border: 3px solid var(--grid-border);
            position: relative;
            z-index: 2;
            transform: rotateX(5deg);
            transition: transform 0.3s ease;
        }

        .sudoku-grid:hover {
            transform: rotateX(0deg);
        }

        .sudoku-grid td {
            border: 1px solid var(--grid-border);
            padding: 0;
            position: relative;
            width: 55px;
            height: 55px;
            background-color: var(--grid-cell);
            transition: all 0.3s ease;
        }

        .sudoku-grid td:nth-child(3n) {
            border-right: 3px solid var(--primary-light);
        }

        .sudoku-grid tr:nth-child(3n) td {
            border-bottom: 3px solid var(--primary-light);
        }

        .sudoku-grid input {
            width: 100%;
            height: 100%;
            text-align: center;
            font-size: 24px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            border: none;
            background: transparent;
            outline: none;
            color: var(--light);
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .sudoku-grid input::placeholder {
            color: rgba(255, 255, 255, 0.2);
        }

        .sudoku-grid input:focus {
            background-color: rgba(76, 201, 240, 0.2);
            box-shadow: inset 0 0 15px rgba(76, 201, 240, 0.5);
            transform: scale(1.05);
            z-index: 10;
        }

        .sudoku-grid input.prefilled {
            color: var(--success);
            text-shadow: 0 0 8px rgba(76, 201, 240, 0.7);
        }

        /* FIXED: Hint styling - made more visible */
        .sudoku-grid input.hint {
            color: var(--warning);
            text-shadow: 0 0 12px rgba(255, 209, 102, 0.9);
            background-color: rgba(255, 209, 102, 0.15);
            animation: hint-pulse 1.5s ease-in-out infinite;
        }

        @keyframes hint-pulse {
            0% { transform: scale(1); box-shadow: inset 0 0 0px rgba(255, 209, 102, 0.5); }
            50% { transform: scale(1.05); box-shadow: inset 0 0 20px rgba(255, 209, 102, 0.8); }
            100% { transform: scale(1); box-shadow: inset 0 0 0px rgba(255, 209, 102, 0.5); }
        }

        .sudoku-grid input.invalid {
            background-color: rgba(239, 71, 111, 0.3);
            color: #ff9eaa;
            animation: shake 0.5s ease-in-out;
            box-shadow: inset 0 0 10px rgba(239, 71, 111, 0.5);
        }

        .sudoku-grid input.highlighted {
            background-color: rgba(67, 97, 238, 0.3);
            box-shadow: inset 0 0 15px rgba(67, 97, 238, 0.7);
            animation: pulse 1.5s infinite;
        }

        .sudoku-grid input.duplicate {
            background-color: rgba(255, 209, 102, 0.3);
            color: #ffd166;
            box-shadow: inset 0 0 10px rgba(255, 209, 102, 0.5);
        }

        .subgrid-0 { background-color: var(--subgrid-1); }
        .subgrid-1 { background-color: var(--subgrid-2); }
        .subgrid-2 { background-color: var(--subgrid-3); }
        .subgrid-3 { background-color: var(--subgrid-2); }
        .subgrid-4 { background-color: var(--subgrid-1); }
        .subgrid-5 { background-color: var(--subgrid-3); }
        .subgrid-6 { background-color: var(--subgrid-3); }
        .subgrid-7 { background-color: var(--subgrid-2); }
        .subgrid-8 { background-color: var(--subgrid-1); }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @keyframes pulse {
            0% { box-shadow: inset 0 0 10px rgba(67, 97, 238, 0.7); }
            50% { box-shadow: inset 0 0 20px rgba(67, 97, 238, 1); }
            100% { box-shadow: inset 0 0 10px rgba(67, 97, 238, 0.7); }
        }

        .control-panel {
            margin: 20px 0;
            padding: 25px;
            background: rgba(30, 30, 46, 0.7);
            border-radius: 20px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3),
                        inset 0 0 15px rgba(67, 97, 238, 0.2);
            border: 1px solid var(--grid-border);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .control-panel::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--success));
        }

        .control-panel h3 {
            text-align: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .control-panel h3::after {
            content: "";
            position: absolute;
            bottom: -1px;
            left: 25%;
            width: 50%;
            height: 2px;
            background: var(--primary);
            box-shadow: 0 0 10px var(--primary);
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(45, 48, 71, 0.6);
            border-radius: 12px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2);
            border: 1px solid var(--grid-border);
        }

        .stat-item {
            text-align: center;
            padding: 10px;
            flex: 1;
            position: relative;
        }

        .stat-item:not(:last-child)::after {
            content: "";
            position: absolute;
            right: 0;
            top: 15%;
            height: 70%;
            width: 1px;
            background: var(--grid-border);
        }

        .stat-label {
            font-size: 14px;
            color: #a9b0c9;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 22px;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
            color: var(--light);
            text-shadow: 0 0 8px rgba(76, 201, 240, 0.7);
        }

        .mistakes-counter { color: var(--danger); }
        .timer-display { color: var(--success); }
        #current-difficulty { color: var(--warning); }

        .panel-section {
            margin-bottom: 25px;
        }

        .panel-section h5 {
            margin-bottom: 15px;
            padding-left: 10px;
            border-left: 3px solid var(--primary);
            color: var(--primary-light);
        }

        .btn-group-custom {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }

        .btn {
            flex: 1;
            min-width: 120px;
            padding: 12px 15px;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: rgba(45, 48, 71, 0.8);
            color: var(--light);
            border: 1px solid var(--grid-border);
        }

        .btn::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 100%;
            background: var(--primary);
            transition: width 0.5s ease;
            z-index: -1;
        }

        .btn:hover::before {
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(67, 97, 238, 0.4);
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-success { border-color: rgba(76, 201, 240, 0.5); color: var(--success); }
        .btn-success::before { background: rgba(76, 201, 240, 0.2); }
        .btn-success:hover { box-shadow: 0 5px 15px rgba(76, 201, 240, 0.4); }

        .btn-info { border-color: rgba(67, 97, 238, 0.5); color: var(--primary-light); }
        .btn-info::before { background: rgba(67, 97, 238, 0.2); }

        .btn-primary { border-color: rgba(243, 114, 182, 0.5); color: var(--accent); }
        .btn-primary::before { background: rgba(243, 114, 182, 0.2); }
        .btn-primary:hover { box-shadow: 0 5px 15px rgba(243, 114, 182, 0.4); }

        .btn-outline-primary { border-color: var(--primary); color: var(--primary-light); }
        .btn-outline-primary:hover { color: white; }

        .btn-outline-secondary { border-color: var(--secondary); color: var(--secondary); }
        .btn-outline-secondary:hover { color: white; }

        .btn-outline-success { border-color: var(--success); color: var(--success); }
        .btn-outline-success:hover { color: white; }

        .btn-outline-danger { border-color: var(--danger); color: var(--danger); }
        .btn-outline-danger:hover { color: white; }

        .btn-outline-info { border-color: var(--primary-light); color: var(--primary-light); }
        .btn-outline-info:hover { color: white; }

        .section-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--grid-border), transparent);
            margin: 25px 0;
            border: none;
        }

        .form-control {
            background: rgba(45, 48, 71, 0.7);
            border: 1px solid var(--grid-border);
            color: var(--light);
            border-radius: 10px;
            padding: 12px 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
            font-family: 'Poppins', sans-serif;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%234361ee' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1em;
        }

        .form-control:focus {
            background: rgba(67, 97, 238, 0.2);
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(67, 97, 238, 0.5);
            color: white;
        }

        .form-control:hover {
            border-color: var(--primary-light);
        }

        .status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px 30px;
            background: rgba(30, 30, 46, 0.95);
            color: white;
            border-top: 1px solid var(--grid-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
        }

        .status-message {
            font-weight: 500;
            font-size: 16px;
            color: var(--primary-light);
        }

        #timer {
            font-family: 'Orbitron', sans-serif;
            font-weight: 600;
            color: var(--success);
            text-shadow: 0 0 8px rgba(76, 201, 240, 0.7);
            font-size: 18px;
        }

        .game-over-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.95);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            margin: 15% auto;
            padding: 30px;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 50px rgba(67, 97, 238, 0.5),
                        inset 0 0 20px rgba(76, 201, 240, 0.3);
            border: 1px solid var(--grid-border);
            position: relative;
            overflow: hidden;
            transform: scale(0.9);
            animation: modal-appear 0.5s forwards;
        }

        @keyframes modal-appear {
            to { transform: scale(1); }
        }

        .modal-content::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: linear-gradient(90deg, var(--primary), var(--accent), var(--success));
        }

        .modal-content h4 {
            font-size: 2.5rem;
            margin-bottom: 20px;
            background: linear-gradient(90deg, var(--accent), var(--primary-light));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        .modal-content p {
            font-size: 1.2rem;
            margin-bottom: 30px;
            color: #a9b0c9;
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .read-more {
            position: absolute;
            bottom: 10px;
            right: 15px;
            background: rgba(67, 97, 238, 0.3);
            color: var(--primary-light);
            border: none;
            border-radius: 5px;
            padding: 3px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .read-more:hover {
            background: rgba(67, 97, 238, 0.5);
            transform: translateY(-2px);
        }

        .error-message {
            color: var(--danger);
            font-size: 16px;
            margin-top: 15px;
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            background: rgba(239, 71, 111, 0.1);
            border: 1px solid rgba(239, 71, 111, 0.3);
            display: none;
        }

        /* Custom dropdown styling */
        .difficulty-selector label {
            display: block;
            margin-bottom: 8px;
            color: #a9b0c9;
            font-size: 14px;
        }

        /* Responsive design */
        @media (max-width: 992px) {
            .sudoku-grid td {
                width: 45px;
                height: 45px;
            }

            .sudoku-grid input {
                font-size: 20px;
            }

            .control-panel {
                padding: 15px;
            }

            .btn {
                min-width: 100px;
                padding: 10px;
            }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }

            .stat-value {
                font-size: 18px;
            }

            .btn {
                padding: 10px 12px;
                font-size: 14px;
            }

            .sudoku-grid td {
                width: 40px;
                height: 40px;
            }

            .sudoku-grid input {
                font-size: 18px;
            }

            .control-panel h3 {
                font-size: 1.5rem;
            }
        }

        @media (max-width: 576px) {
            .game-stats {
                flex-direction: column;
                gap: 15px;
            }

            .stat-item:not(:last-child)::after {
                display: none;
            }

            .header-section {
                padding: 10px 0;
            }

            .status-bar {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }

            .control-panel {
                margin-top: 15px;
            }
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(30, 30, 46, 0.3);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--primary-light);
        }

        /* Tooltip styling */
        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: rgba(30, 30, 46, 0.9);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 15px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--grid-border);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            font-size: 14px;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: rgba(30, 30, 46, 0.9) transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Compact controls */
        .compact-controls {
            max-height: 450px;
            overflow-y: auto;
            padding-right: 8px;
        }

        .compact-controls::-webkit-scrollbar {
            width: 6px;
        }
    </style>
</head>
<body>
<div class="container-fluid">

    <div class="row">
        <div class="col-lg-8 col-md-7">
            <h1 class="text-center mt-3 mb-4">Advanced Sudoku Game</h1>
            <div class="d-flex justify-content-center">
                <table class="sudoku-grid">
                    <tbody id="sudoku-tbody">
                    <!-- Grid will be generated by JavaScript -->
                    </tbody>
                </table>
            </div>
            <div class="error-message text-center" id="error-message"></div>
        </div>

        <div class="col-lg-4 col-md-5">
            <div class="control-panel">
                <h3 class="text-center mb-4">Sudoku Controls</h3>

                <!-- Game Stats -->
                <div class="game-stats">
                    <div class="stat-item">
                        <div class="stat-label">Mistakes</div>
                        <div class="stat-value mistakes-counter" id="mistakes-display">0/3</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Timer</div>
                        <div class="stat-value timer-display" id="timer-display">00:00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Difficulty</div>
                        <div class="stat-value" id="current-difficulty">Medium</div>
                    </div>
                </div>

                <!-- Solving Actions -->
                <div class="solving-actions">
                    <h5>Solve Puzzle</h5>
                    <div class="btn-group-custom">
                        <button class="btn btn-success" onclick="solve('backtracking')">
                            🚀 Solve Puzzle
                        </button>
                        <button class="btn btn-info" onclick="getHint()">
                            💡 Get Hint
                        </button>
                    </div>
                </div>

                <div class="section-divider"></div>

                <!-- Puzzle Generation -->
                <div class="puzzle-actions">
                    <h5>Generate New Puzzle</h5>
                    <div class="difficulty-selector">
                        <label for="difficulty">Difficulty Level:</label>
                        <select id="difficulty" class="form-control">
                            <option value="easy">Easy (40 clues)</option>
                            <option value="medium" selected>Medium (30 clues)</option>
                            <option value="hard">Hard (25 clues)</option>
                        </select>
                    </div>
                    <button class="btn btn-primary btn-block" onclick="generatePuzzle()">
                        🎲 Generate Puzzle
                    </button>
                </div>

                <div class="section-divider"></div>

                <!-- Puzzle Management -->
                <div class="puzzle-actions">
                    <h5>Puzzle Management</h5>
                    <div class="btn-group-custom">
                        <button class="btn btn-outline-primary" onclick="savePuzzle()">
                            💾 Save Puzzle
                        </button>
                        <button class="btn btn-outline-secondary" onclick="loadPuzzle()">
                            📁 Load Puzzle
                        </button>
                    </div>
                </div>

                <div class="section-divider"></div>

                <!-- Utility Actions -->
                <div class="utility-actions">
                    <h5>Utilities</h5>
                    <div class="btn-group-custom">
                        <button class="btn btn-outline-success" onclick="validateBoard()">
                            ✅ Validate
                        </button>
                        <button class="btn btn-outline-danger" onclick="clearBoard()">
                            🗑️ Clear Board
                        </button>
                        <button class="btn btn-outline-info" onclick="resetTimer()">
                            ⏰ Reset Timer
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Fixed Status Bar -->
<div class="status-bar">
    <span id="status" class="status-message">Generate a new puzzle to start playing!</span>
    <span id="timer" class="timer-display">Time: 00:00</span>
</div>

<!-- Game Over Modal -->
<div id="gameOverModal" class="game-over-modal">
    <div class="modal-content">
        <h4>Game Over</h4>
        <p id="gameOverMessage">You have made 3 mistakes and lost this game</p>
        <button class="btn btn-primary" onclick="secondChance()">Second Chance</button>
        <button class="btn btn-secondary" onclick="newGame()">New Game</button>
    </div>
</div>

<!-- Loading Scripts -->
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
<script>
    let board = Array(9).fill().map(() => Array(9).fill('.'));
    let originalBoard = Array(9).fill().map(() => Array(9).fill('.'));
    let solution = Array(9).fill().map(() => Array(9).fill('.'));
    let isSolving = false;
    let timerInterval;
    let gameStarted = false;
    let mistakes = 0;
    let maxMistakes = 3;
    let gameOver = false;
    let savedPuzzles = [];
    let currentFocusedCell = null;

    // Initialize game
    $(document).ready(function() {
    generateGrid();
    updateGrid();
    $('#status').text('Generate a new puzzle to start playing!');
    loadSavedPuzzles();
    // Remove this line: loadExamplePuzzle();
});

    function generateGrid() {
        let gridHTML = '';
        for (let i = 0; i < 9; i++) {
            gridHTML += '<tr>';
            for (let j = 0; j < 9; j++) {
                const isSubgrid = (Math.floor(i / 3) + Math.floor(j / 3)) % 2 === 0;
                const subgridClass = isSubgrid ? 'subgrid' : '';
                gridHTML += `<td>
                    <input type="text"
                           maxlength="1"
                           pattern="[1-9]?"
                           class="${subgridClass}"
                           id="cell-${i}-${j}"
                           oninput="updateBoard(this, ${i}, ${j})"
                           onkeydown="handleKeyDown(event, ${i}, ${j})"
                           onfocus="handleCellFocus(${i}, ${j})"
                           onblur="handleCellBlur(${i}, ${j})"
                           autocomplete="off">
                </td>`;
            }
            gridHTML += '</tr>';
        }
        $('#sudoku-tbody').html(gridHTML);
    }

    function handleKeyDown(event, row, col) {
        if (gameOver) return;

        // Allow backspace and delete
        if (event.key === 'Backspace' || event.key === 'Delete') {
            if (originalBoard[row][col] === '.') {
                board[row][col] = '.';
                $(`#cell-${row}-${col}`).val('');
                clearValidationHighlights();
                validateBoardRealTime();
            }
            return;
        }

        // Only allow numbers 1-9
        if (event.key >= '1' && event.key <= '9') {
            return true;
        }

        // Arrow key navigation
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
            navigateGrid(event.key, row, col);
            event.preventDefault();
            return false;
        }

        // Block all other keys
        event.preventDefault();
        return false;
    }

    function navigateGrid(key, row, col) {
        let newRow = row;
        let newCol = col;

        switch(key) {
            case 'ArrowUp':
                newRow = row > 0 ? row - 1 : 8;
                break;
            case 'ArrowDown':
                newRow = row < 8 ? row + 1 : 0;
                break;
            case 'ArrowLeft':
                newCol = col > 0 ? col - 1 : 8;
                break;
            case 'ArrowRight':
                newCol = col < 8 ? col + 1 : 0;
                break;
        }

        $(`#cell-${newRow}-${newCol}`).focus();
    }

    function handleCellFocus(row, col) {
        currentFocusedCell = {row, col};
        highlightRelatedCells(row, col);
    }

    function handleCellBlur(row, col) {
        currentFocusedCell = null;
        clearHighlights();
    }

    function highlightRelatedCells(row, col) {
        clearHighlights();

        // Highlight same row, column, and 3x3 box
        for (let i = 0; i < 9; i++) {
            // Same row
            if (i !== col) {
                $(`#cell-${row}-${i}`).addClass('highlighted');
            }
            // Same column
            if (i !== row) {
                $(`#cell-${i}-${col}`).addClass('highlighted');
            }
        }

        // Same 3x3 box
        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (i !== row || j !== col) {
                    $(`#cell-${i}-${j}`).addClass('highlighted');
                }
            }
        }
    }

    function clearHighlights() {
        $('.sudoku-grid input').removeClass('highlighted');
    }

    function updateBoard(element, i, j) {
        if (gameOver) return;

        const value = element.value;
        const oldValue = board[i][j];

        // Only allow digits 1-9 or empty
        if (value !== '' && !value.match(/^[1-9]$/)) {
            element.value = board[i][j] === '.' ? '' : board[i][j];
            return;
        }

        // Don't allow modification of prefilled cells
        if (originalBoard[i][j] !== '.') {
            element.value = originalBoard[i][j];
            return;
        }

        // Start timer on first move
        if (!gameStarted && value !== '') {
            startTimer();
            gameStarted = true;
        }

        board[i][j] = value === '' ? '.' : value;

        // Clear previous validation highlights
        clearValidationHighlights();

        // Real-time validation
        validateBoardRealTime();

        // Check for validity and handle mistakes
        if (value !== '' && !isValidMove(i, j, value)) {
            element.classList.add('invalid');
            showError(`Invalid move: ${value} conflicts with existing numbers`);

            if (oldValue !== value) {
                mistakes++;
                updateMistakesDisplay();

                if (mistakes >= maxMistakes) {
                    setTimeout(() => endGame(), 500);
                }
            }
        } else {
            element.classList.remove('invalid');
            hideError();

            if (isPuzzleComplete()) {
                setTimeout(() => completePuzzle(), 500);
            }
        }
    }

    function validateBoardRealTime() {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const value = board[i][j];
                if (value !== '.') {
                    const cell = $(`#cell-${i}-${j}`);

                    if (hasDuplicates(i, j, value)) {
                        cell.addClass('duplicate');
                    } else {
                        cell.removeClass('duplicate');
                    }
                }
            }
        }
    }

    function hasDuplicates(row, col, value) {
        for (let j = 0; j < 9; j++) {
            if (j !== col && board[row][j] === value) {
                return true;
            }
        }

        for (let i = 0; i < 9; i++) {
            if (i !== row && board[i][col] === value) {
                return true;
            }
        }

        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if ((i !== row || j !== col) && board[i][j] === value) {
                    return true;
                }
            }
        }

        return false;
    }

    function clearValidationHighlights() {
        $('.sudoku-grid input').removeClass('duplicate invalid');
    }

    function showError(message) {
        $('#error-message').text(message).show();
        setTimeout(() => hideError(), 3000);
    }

    function hideError() {
        $('#error-message').hide();
    }

    function isValidMove(row, col, num) {
        const tempBoard = board.map(row => [...row]);

        for (let i = 0; i < 9; i++) {
            if (i !== col && tempBoard[row][i] === num) {
                return false;
            }
        }

        for (let i = 0; i < 9; i++) {
            if (i !== row && tempBoard[i][col] === num) {
                return false;
            }
        }

        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if ((i !== row || j !== col) && tempBoard[i][j] === num) {
                    return false;
                }
            }
        }

        return true;
    }

    function solve(method) {
        if (isSolving || gameOver) return;

        isSolving = true;
        $('#status').text('Solving...');

        setTimeout(() => {
            const boardCopy = board.map(row => [...row]);
            if (solveSudoku(boardCopy)) {
                board = boardCopy;
                solution = boardCopy.map(row => [...row]);
                updateGrid();
                $('#status').text('Puzzle solved!');
                stopTimer();
                gameOver = true;
            } else {
                $('#status').text('No solution found!');
            }
            isSolving = false;
        }, 500);
    }

    function getHint() {
        if (gameOver) return;

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] === '.' && originalBoard[i][j] === '.') {
                    const solutionCopy = board.map(row => [...row]);
                    if (solveSudoku(solutionCopy)) {
                        const hintValue = solutionCopy[i][j];
                        board[i][j] = hintValue;
                        updateGrid();
                        $(`#cell-${i}-${j}`).addClass('hint-cell').css('background-color', '#e8f5e8');
                        $('#status').text(`Hint: Added ${hintValue} at row ${i+1}, column ${j+1}`);

                        if (isPuzzleComplete()) {
                            setTimeout(() => completePuzzle(), 500);
                        }
                        return;
                    }
                }
            }
        }

        $('#status').text('No hints available - puzzle might be complete!');
    }

    function solveSudoku(board) {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = 1; num <= 9; num++) {
                        if (isValidPlacement(board, row, col, num.toString())) {
                            board[row][col] = num.toString();
                            if (solveSudoku(board)) {
                                return true;
                            }
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    function isValidPlacement(board, row, col, num) {
        for (let i = 0; i < 9; i++) {
            if (board[row][i] === num) return false;
        }

        for (let i = 0; i < 9; i++) {
            if (board[i][col] === num) return false;
        }

        const startRow = 3 * Math.floor(row / 3);
        const startCol = 3 * Math.floor(col / 3);
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                if (board[i][j] === num) return false;
            }
        }

        return true;
    }

    function loadExamplePuzzle() {
    if (confirm('Load example puzzle? This will replace current game.')) {
        const examplePuzzle = [
            ['4', '.', '7', '.', '.', '.', '.', '.', '.'],
            ['.', '5', '.', '7', '.', '.', '.', '4', '.'],
            ['.', '1', '9', '.', '.', '4', '7', '.', '8'],
            ['8', '2', '.', '6', '7', '5', '9', '4', '1'],
            ['1', '6', '5', '4', '9', '8', '.', '.', '7'],
            ['7', '4', '.', '2', '1', '3', '5', '.', '6'],
            ['5', '7', '8', '9', '4', '2', '.', '.', '.'],
            ['2', '3', '1', '8', '5', '6', '4', '7', '9'],
            ['6', '9', '4', '1', '3', '7', '.', '.', '2']
        ];

        board = examplePuzzle.map(row => [...row]);
        originalBoard = examplePuzzle.map(row => [...row]);

        resetGame();
        updateGrid();
        $('#status').text('Example puzzle loaded! Start playing.');
        $('#current-difficulty').text('Example');
    }
}

    function generatePuzzle() {
        if (gameOver) return;

        $('#status').text('Generating puzzle...');

        const difficulty = $('#difficulty').val();
        $('#current-difficulty').text(difficulty.charAt(0).toUpperCase() + difficulty.slice(1));

        setTimeout(() => {
            const newBoard = Array(9).fill().map(() => Array(9).fill('.'));

            for (let i = 0; i < 9; i += 3) {
                fillBox(newBoard, i, i);
            }

            if (!solveSudoku(newBoard)) {
                $('#status').text('Failed to generate a valid puzzle!');
                return;
            }

            solution = newBoard.map(row => [...row]);
            let clues;
            switch (difficulty) {
                case 'easy': clues = 40; break;
                case 'medium': clues = 30; break;
                case 'hard': clues = 25; break;
                default: clues = 30;
            }

            const positions = [];
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    positions.push([i, j]);
                }
            }
            shuffleArray(positions);

            let removed = 0;
            const tempBoard = newBoard.map(row => [...row]);
            for (const [row, col] of positions) {
                if (removed >= 81 - clues) break;
                const backup = tempBoard[row][col];
                tempBoard[row][col] = '.';
                const tempSolution = tempBoard.map(row => [...row]);
                if (solveSudoku(tempSolution)) {
                    newBoard[row][col] = '.';
                    removed++;
                } else {
                    tempBoard[row][col] = backup;
                }
            }

            board = newBoard;
            originalBoard = newBoard.map(row => [...row]);

            resetGame();
            updateGrid();
            $('#status').text(`New ${difficulty} puzzle generated! Start playing.`);
        }, 500);
    }

    function fillBox(board, startRow, startCol) {
        const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];
        shuffleArray(numbers);

        let index = 0;
        for (let i = startRow; i < startRow + 3; i++) {
            for (let j = startCol; j < startCol + 3; j++) {
                board[i][j] = numbers[index++].toString();
            }
        }
    }

    function removeNumbers(board, clues) {
        const numbersToRemove = 81 - clues;
        const positions = [];

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                positions.push([i, j]);
            }
        }

        shuffleArray(positions);

        let removed = 0;
        for (const [row, col] of positions) {
            if (removed >= numbersToRemove) break;

            board[row][col] = '.';
            removed++;
        }
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function savePuzzle() {
        if (board.every(row => row.every(cell => cell === '.'))) {
            $('#status').text('No puzzle to save!');
            return;
        }

        const puzzle = {
            id: Date.now(),
            board: board.map(row => row.join('')).join('\n'),
            original: originalBoard.map(row => row.join('')).join('\n'),
            difficulty: $('#difficulty').val(),
            createdAt: new Date().toISOString()
        };

        savedPuzzles.push(puzzle);
        try {
            localStorage.setItem('sudokuPuzzles', JSON.stringify(savedPuzzles));
            $('#status').text(`Puzzle saved successfully! ID: ${puzzle.id}`);
        } catch (error) {
            $('#status').text('Error saving puzzle!');
        }
    }

    function loadPuzzle() {
        if (savedPuzzles.length === 0) {
            $('#status').text('No saved puzzles found!');
            return;
        }

        const puzzleId = prompt('Enter puzzle ID to load:');
        if (!puzzleId) return;

        const puzzle = savedPuzzles.find(p => p.id.toString() === puzzleId);
        if (!puzzle) {
            $('#status').text('Puzzle not found!');
            return;
        }

        const boardData = puzzle.board.split('\n').map(row => row.split(''));
        const originalData = puzzle.original.split('\n').map(row => row.split(''));

        board = boardData;
        originalBoard = originalData;

        resetGame();
        updateGrid();
        $('#status').text(`Puzzle ${puzzleId} loaded successfully!`);
        $('#current-difficulty').text(puzzle.difficulty.charAt(0).toUpperCase() + puzzle.difficulty.slice(1));
    }

    function loadSavedPuzzles() {
        try {
            const saved = localStorage.getItem('sudokuPuzzles');
            if (saved) {
                savedPuzzles = JSON.parse(saved);
            }
        } catch (error) {
            console.error('Error loading saved puzzles:', error);
        }
    }

    function validateBoard() {
        if (gameOver) return;

        let isValid = true;
        let errorCount = 0;

        $('.sudoku-grid input').removeClass('invalid duplicate');

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const value = board[i][j];
                if (value !== '.') {
                    if (!isValidMove(i, j, value)) {
                        isValid = false;
                        errorCount++;
                        $(`#cell-${i}-${j}`).addClass('invalid');
                    }
                }
            }
        }

        if (isValid) {
            $('#status').text('Board validation passed! ✅');
        } else {
            $('#status').text(`Board validation failed! ${errorCount} errors found. ❌`);
        }
    }

    function clearBoard() {
        if (confirm('Are you sure you want to clear the board?')) {
            for (let i = 0; i < 9; i++) {
                for (let j = 0; j < 9; j++) {
                    if (originalBoard[i][j] === '.') {
                        board[i][j] = '.';
                    }
                }
            }
            updateGrid();
            clearValidationHighlights();
            $('#status').text('Board cleared!');
        }
    }

    function resetTimer() {
        stopTimer();
        timerInterval = null;
        gameStarted = false;
        $('#timer-display').text('00:00');
        $('#timer').text('Time: 00:00');
        $('#status').text('Timer reset!');
    }

    function resetGame() {
        mistakes = 0;
        gameOver = false;
        gameStarted = false;
        stopTimer();
        updateMistakesDisplay();
        clearValidationHighlights();
        $('.sudoku-grid input').removeClass('invalid duplicate hint-cell');
        $('#gameOverModal').hide();
    }

    function updateGrid() {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const cell = $(`#cell-${i}-${j}`);
                const value = board[i][j];

                cell.val(value === '.' ? '' : value);

                if (originalBoard[i][j] !== '.') {
                    cell.addClass('prefilled');
                    cell.prop('readonly', true);
                } else {
                    cell.removeClass('prefilled');
                    cell.prop('readonly', false);
                }
            }
        }
    }

    function startTimer() {
        if (timerInterval) return;

        let seconds = 0;
        timerInterval = setInterval(() => {
            seconds++;
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;

            $('#timer-display').text(timeString);
            $('#timer').text(`Time: ${timeString}`);
        }, 1000);
    }

    function stopTimer() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    function updateMistakesDisplay() {
        $('#mistakes-display').text(`${mistakes}/${maxMistakes}`);
    }

    function isPuzzleComplete() {
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (board[i][j] === '.') {
                    return false;
                }
            }
        }

        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (!isValidMove(i, j, board[i][j])) {
                    return false;
                }
            }
        }

        return true;
    }

    function completePuzzle() {
        stopTimer();
        gameOver = true;
        const timeString = $('#timer-display').text();
        $('#status').text(`🎉 Congratulations! Puzzle completed in ${timeString} with ${mistakes} mistakes!`);

        $('.sudoku-grid').addClass('pulse');
        setTimeout(() => {
            $('.sudoku-grid').removeClass('pulse');
        }, 1000);
    }

    function endGame() {
        stopTimer();
        gameOver = true;
        $('#gameOverMessage').text(`You have made ${maxMistakes} mistakes and lost this game.`);
        $('#gameOverModal').show();
        $('#status').text('Game Over - Too many mistakes!');
    }

    function secondChance() {
        mistakes = 0;
        gameOver = false;
        updateMistakesDisplay();
        $('#gameOverModal').hide();
        $('#status').text('Second chance granted! Be careful with your moves.');

        $('.sudoku-grid input').removeClass('invalid');

        if (gameStarted) {
            startTimer();
        }
    }

    function newGame() {
        $('#gameOverModal').hide();
        generatePuzzle();
    }

    $('<style>').text(`
        .pulse {
            animation: pulse 1s ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
    `).appendTo('head');

    $(document).keydown(function(e) {
        if (gameOver) return;

        if (e.ctrlKey && e.key === 'n') {
            e.preventDefault();
            generatePuzzle();
        }

        if (e.ctrlKey && e.key === 's') {
            e.preventDefault();
            savePuzzle();
        }

        if (e.ctrlKey && e.key === 'l') {
            e.preventDefault();
            loadPuzzle();
        }

        if (e.ctrlKey && e.key === 'h') {
            e.preventDefault();
            getHint();
        }

        if (e.ctrlKey && e.key === 'v') {
            e.preventDefault();
            validateBoard();
        }

        if (e.key === 'Escape') {
            $('#gameOverModal').hide();
        }
    });

    $(document).click(function(e) {
        if ($(e.target).is('#gameOverModal')) {
            $('#gameOverModal').hide();
        }
    });

    setInterval(function() {
        if (gameStarted && !gameOver && !board.every(row => row.every(cell => cell === '.'))) {
            const autoSave = {
                id: 'autosave',
                board: board.map(row => row.join('')).join('\n'),
                original: originalBoard.map(row => row.join('')).join('\n'),
                difficulty: $('#difficulty').val(),
                createdAt: new Date().toISOString(),
                mistakes: mistakes,
                time: $('#timer-display').text()
            };

            try {
                localStorage.setItem('sudokuAutoSave', JSON.stringify(autoSave));
            } catch (error) {
                console.error('Auto-save failed:', error);
            }
        }
    }, 30000);

    function loadAutoSave() {
        try {
            const autoSave = localStorage.getItem('sudokuAutoSave');
            if (autoSave) {
                const data = JSON.parse(autoSave);
                if (confirm('Auto-saved game found. Would you like to continue?')) {
                    const boardData = data.board.split('\n').map(row => row.split(''));
                    const originalData = data.original.split('\n').map(row => row.split(''));

                    board = boardData;
                    originalBoard = originalData;
                    mistakes = data.mistakes || 0;

                    resetGame();
                    updateGrid();
                    updateMistakesDisplay();
                    $('#status').text('Auto-saved game loaded!');
                    $('#current-difficulty').text(data.difficulty.charAt(0).toUpperCase() + data.difficulty.slice(1));
                }
            }
        } catch (error) {
            console.error('Error loading auto-save:', error);
        }
    }

    setTimeout(loadAutoSave, 1000);
</script>
</body>
</html>